<!doctype html>
<html lang="it">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Beachball viewer (Three.js) — Correzione finale Shader</title>
<style>
  html,body { height:100%; margin:0; background:#e9e9e9; font-family:system-ui,Segoe UI,Roboto,Arial; }
  #app { height:100vh; display:flex; flex-direction:column; }
  #topbar { padding:8px; background:#fff; box-shadow:0 1px 4px rgba(0,0,0,0.06); display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
  #canvaswrap { flex:1; position:relative; overflow:hidden; }
  canvas { display:block; width:100%; height:100%; }
  label { font-size:13px; }
  input[type="file"] { display:inline-block; }
  .controls { margin-left:auto; display:flex; gap:8px; align-items:center; }

  #tooltip {
    position: absolute;
    display: none;
    padding: 8px;
    background: rgba(0,0,0,0.75);
    color: white;
    border-radius: 4px;
    font-size: 12px;
    pointer-events: none;
    line-height: 1.4;
  }
</style>

<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@latest/build/three.module.js",
    "three/addons/": "https://cdn.jsdelivr.net/npm/three@latest/examples/jsm/"
  }
}
</script>
</head>
<body>
<div id="app">
  <div id="topbar">
    <label class="info">CSV (X,Y,Z,Md,Time,Strike,Dip,Rake):</label>
    <input id="file" type="file" accept=".csv" />

    <div class="controls">
      <label>Moltiplicatore Raggio (Md³ * X):</label>
      <input id="radiusScale" type="range" min="0.1" max="3" step="0.05" value="1.5" />
      <span id="scaleVal">1.5</span>

      <label style="margin-left:10px;"><input id="showPlanes" type="checkbox" checked /> mostra piani di faglia</label>
    </div>
  </div>

  <div id="canvaswrap">
    <div id="tooltip"></div>
  </div>
</div>

<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

// --- ELEMENTI DOM ---
const container = document.getElementById('canvaswrap');
const fileInput = document.getElementById('file');
const showPlanesCheckbox = document.getElementById('showPlanes');
const tooltip = document.getElementById('tooltip');
const radiusScaleInput = document.getElementById('radiusScale');
const scaleValSpan = document.getElementById('scaleVal');

// --- VARIABILI GLOBALI ---
let scene, camera, renderer, controls;
let rootGroup;
let raycaster, mouse;

let lastLoadedRows = [];
let sceneCenterOffset = new THREE.Vector3(0, 0, 0);

const d2r = deg => deg * Math.PI / 180;

// --- INIZIALIZZAZIONE ---
initScene();
animate();

function initScene(){
  scene = new THREE.Scene();
  scene.background = new THREE.Color(0xe9e9e9);

  const w = container.clientWidth, h = container.clientHeight;
  camera = new THREE.PerspectiveCamera(45, w/h, 0.01, 1e7);
  camera.position.set(5000, 5000, 5000);

  renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setPixelRatio(window.devicePixelRatio);
  renderer.setSize(container.clientWidth, container.clientHeight);
  container.appendChild(renderer.domElement);

  controls = new OrbitControls(camera, renderer.domElement);
  controls.target.set(0,0,0);

  controls.minDistance = 0.01;
  controls.maxDistance = 10000;
  controls.zoomSpeed = 10.0;
  controls.enableDamping = true;
  controls.dampingFactor = 0.05;
  controls.mouseButtons.LEFT = THREE.MOUSE.ROTATE;
  controls.mouseButtons.MIDDLE = THREE.MOUSE.DOLLY;
  controls.mouseButtons.RIGHT = THREE.MOUSE.PAN;
  controls.update();

  scene.add(new THREE.DirectionalLight(0xffffff, 0.9));
  scene.add(new THREE.AmbientLight(0xffffff, 0.35));

  rootGroup = new THREE.Group();
  scene.add(rootGroup);

  raycaster = new THREE.Raycaster();
  mouse = new THREE.Vector2();

  renderer.domElement.addEventListener('click', onCanvasClick);
  controls.addEventListener('start', () => {
    tooltip.style.display = 'none';
  });

  scaleValSpan.textContent = radiusScaleInput.value;
  radiusScaleInput.addEventListener('input', () => {
    scaleValSpan.textContent = radiusScaleInput.value;
    updateSceneFromData();
  });

  showPlanesCheckbox.addEventListener('change', () => {
    updateSceneFromData();
  });

  window.addEventListener('resize', onWindowResize);
}

/**
 * Funzione Vettori ENU con le correzioni angolari richieste (Strike-90, 90-Dip, -Rake).
 */
function get_enu_vectors(strikeDeg, dipDeg, rakeDeg) {
  // 1. Angoli Corretti
  const phi = d2r(strikeDeg - 90.0); // Correzione Strike (da Nord -> da Est)
  const delta = d2r(90.0 - dipDeg);  // Correzione Dip (Plunge -> Dip)
  const lam = d2r(-rakeDeg);         // Correzione Rake (Inversione segno per convenzione)

  const sd = Math.sin(delta), cd = Math.cos(delta);
  const sp = Math.sin(phi),   cp = Math.cos(phi);
  const sl = Math.sin(lam),   cl = Math.cos(lam);

  // 2. Formule Vettori Aki & Richards (1980) - ENU convention (X=E, Y=N, Z=U)

  // Vettore Normale (n)
  const n_e = sd * sp;
  const n_n = -sd * cp;
  const n_u = cd;

  // Vettore Slip (s)
  const s_e = cl * cp + cd * sl * sp;
  const s_n = cl * sp - cd * sl * cp;
  const s_u = -sd * sl;

  const n_enu = new THREE.Vector3(n_e, n_n, n_u);
  const s_enu = new THREE.Vector3(s_e, s_n, s_u);

  return { n_enu, s_enu };
}

/**
 * Ottiene i vettori ENU e li trasforma in Three.js (Y-Up).
 * Applica una rotazione di 90° sul piano orizzontale (E-N) solo per la beachball.
 */
function get_threejs_vectors(strike, dip, rake) {
  const { n_enu, s_enu } = get_enu_vectors(strike, dip, rake);

  // --- VETTORE NORMALE PER IL PIANO GIALLO (NON RUOTATO) ---
  // ENU (X_E, Y_N, Z_U) -> Three.js (X=E, Y=U, Z=-N)
  const n_three_plane = new THREE.Vector3(n_enu.x, n_enu.z, -n_enu.y).normalize();

  // --- VETTORI PER LA BEACHBALL (RUOTATI DI 90° ANTICIPATO) ---
  // Rotazione di 90 gradi antioraria sul piano (E, N): E' = N, N' = -E

  const n_rot_e = n_enu.y;
  const n_rot_n = -n_enu.x;
  const n_rot_u = n_enu.z;

  const s_rot_e = s_enu.y;
  const s_rot_n = -s_enu.x;
  const s_rot_u = s_enu.z;

  // Vettori ruotati, trasformati in Y-Up di Three.js (X=E', Y=U, Z=-N')
  const n_three_ball = new THREE.Vector3(n_rot_e, n_rot_u, -n_rot_n).normalize();
  const s_three_ball = new THREE.Vector3(s_rot_e, s_rot_u, -s_rot_n).normalize();

  return {
      n_plane: n_three_plane,
      n_ball: n_three_ball,
      s_ball: s_three_ball
  };
}

// Calcola il tensore momento usando i vettori ruotati (n_ball, s_ball)
function buildMomentTensorFromSDR(strike, dip, rake) {
  const { n_ball, s_ball } = get_threejs_vectors(strike, dip, rake);

  const n = n_ball;
  const s = s_ball;

  // Calcolo tensore M = s*n + n*s
  const M = [
    s.x * n.x + n.x * s.x, s.x * n.y + n.x * s.y, s.x * n.z + n.x * s.z,
    s.y * n.x + n.y * s.x, s.y * n.y + n.y * s.y, s.y * n.z + n.y * s.z,
    s.z * n.x + n.z * s.x, s.z * n.y + n.z * s.y, s.z * n.z + n.z * s.z
  ];

  return M;
}

/**
 * Materiale Shader con calcoli in World Space per fissare l'orientamento.
 */
function makeMomentBallMaterial(momentArray) {
  const mat = new THREE.ShaderMaterial({
    uniforms: {
      lightDir: { value: new THREE.Vector3(1,2,3).normalize() },
      M: { value: momentArray.map(v=>v) },
      colorComp: { value: new THREE.Color(0xc00000) }, // Rosso (Compressione)
      colorDilat: { value: new THREE.Color(0xf0f0f0) } // Bianco (Dilatazione)
    },
    vertexShader: `
      // modelMatrix e normalMatrix sono uniformi di default in Three.js, non vanno ridichiarate.
      varying vec3 vWNormal; // World Space Normal

      void main(){
        // Trasforma la normale da Model a World Space
        vWNormal = normalize((modelMatrix * vec4(normal, 0.0)).xyz);
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);
      }`,
    fragmentShader: `
      uniform vec3 lightDir;
      uniform float M[9];
      uniform vec3 colorComp;
      uniform vec3 colorDilat;
      varying vec3 vWNormal; // La normale in World Space

      vec3 Mmul_u(vec3 u) {
        // Moltiplicazione M * u (dove u è la normale in World Space)
        return vec3(
          M[0]*u.x + M[1]*u.y + M[2]*u.z,
          M[3]*u.x + M[4]*u.y + M[5]*u.z,
          M[6]*u.x + M[7]*u.y + M[8]*u.z
        );
      }
      void main(){
        vec3 u = normalize(vWNormal); // La normale è ora fissa nello spazio
        vec3 Mu = Mmul_u(u);

        // Calcolo del tensore: sigma è fisso rispetto al mondo
        float sigma = dot(u, Mu);
        float t = smoothstep(-0.0006, 0.0006, sigma);
        vec3 baseCol = mix(colorComp, colorDilat, t);

        // Calcolo illuminazione: LightDir è in World Space
        float L = max(dot(u, normalize(lightDir)), 0.0);
        vec3 shaded = baseCol * (0.25 + 0.75 * L);
        gl_FragColor = vec4(shaded, 1.0);
      }`,
    side: THREE.DoubleSide
  });
  return mat;
}

function createEventMesh(relX, relY, relZ, origX, origY, origZ, Md, strike, dip, rake, options = {}) {

  const radiusMultiplier = options.radiusMultiplier ?? 1.5;
  const minRadius = 5.0;
  const radius = Math.max(minRadius, (Md ** 3) * radiusMultiplier);

  const { n_plane } = get_threejs_vectors(strike, dip, rake);

  const M = buildMomentTensorFromSDR(strike, dip, rake);
  const mat = makeMomentBallMaterial(M);
  const geom = new THREE.SphereGeometry(radius, 96, 64);
  const sph = new THREE.Mesh(geom, mat);

  const group = new THREE.Group();
  group.add(sph);

  if (showPlanesCheckbox.checked) {
    const planeSize = radius * 6;

    const planeGeometry = new THREE.PlaneGeometry(planeSize, planeSize);
    const planeMaterial = new THREE.MeshBasicMaterial({
      color: 0xffea66, opacity: 0.55, transparent: true, side: THREE.DoubleSide, depthWrite: false
    });
    const plane = new THREE.Mesh(planeGeometry, planeMaterial);

    // Allineamento Piano: Usa n_plane (vettore non ruotato, fisso)
    const zAxisDefault = new THREE.Vector3(0, 0, 1);
    const rotationQuaternion = new THREE.Quaternion().setFromUnitVectors(zAxisDefault, n_plane);

    plane.quaternion.copy(rotationQuaternion);

    plane.position.copy(n_plane).multiplyScalar(0.0001);

    group.add(plane);
  }

  // POSIZIONAMENTO SPAZIALE
  const posx = relX; // X (East)
  const posy = relZ; // Y (Up/Down) <- Z_UTM
  const posz = -relY; // Z (North/South) <- Y_UTM

  group.position.set(posx, posy, posz);

  group.userData = {
    displayData: {
      X: origX.toFixed(2), Y: origY.toFixed(2), Z: origZ.toFixed(2),
      Md: Md.toFixed(2), Strike: strike.toFixed(2), Dip: dip.toFixed(2), Rake: rake.toFixed(2)
    }
  };

  return group;
}

// --- Funzioni di gestione dati (invariate) ---

function parseCSV(text) {
  const lines = text.trim().split(/\r?\n/).map(l=>l.trim()).filter(l=>l.length>0);
  if (lines.length < 2) return [];
  const header = lines[0].split(',').map(s=>s.trim());
  const rows = [];
  for (let i=1;i<lines.length;i++){
    const cols = lines[i].split(',').map(s=>s.trim());
    if (cols.length < header.length) { continue; }
    const obj = {};
    for (let j=0;j<header.length;j++){ obj[header[j]] = cols[j]; }
    rows.push(obj);
  }
  return rows;
}

function clearEvents() {
  while (rootGroup.children.length) {
    const c = rootGroup.children[0];
    c.traverse(o=>{
      if (o.geometry) { o.geometry.dispose(); }
      if (o.material) {
        if (Array.isArray(o.material)) o.material.forEach(m=>m.dispose());
        else o.material.dispose();
      }
    });
    rootGroup.remove(c);
  }
}

function updateSceneFromData() {
  if (lastLoadedRows.length === 0) { return; }

  clearEvents();

  const currentRadiusMultiplier = parseFloat(radiusScaleInput.value);

  const bbox = new THREE.Box3();

  lastLoadedRows.forEach(r=>{
    const M_val = r.Md || r.Ml;

    const x = parseFloat(r.X), y = parseFloat(r.Y), z = parseFloat(r.Z);
    const Md = parseFloat(M_val) || 1.0;
    const strike = parseFloat(r.Strike) || 0;
    const dip = parseFloat(r.Dip) || 90;
    const rake = parseFloat(r.Rake) || 0;

    if (isNaN(x)||isNaN(y)||isNaN(z)) return;

    const relX = x - sceneCenterOffset.x;
    const relY = y - sceneCenterOffset.y;
    const relZ = z - sceneCenterOffset.z;

    const meshGroup = createEventMesh(
      relX, relY, relZ,
      x, y, z,
      Md, strike, dip, rake,
      { radiusMultiplier: currentRadiusMultiplier }
    );

    rootGroup.add(meshGroup);

    bbox.expandByPoint(meshGroup.position);
  });

  if (controls.target.lengthSq() < 1) {
    const center = new THREE.Vector3();
    bbox.getCenter(center);
    const size = new THREE.Vector3();
    bbox.getSize(size);
    const maxDim = Math.max(size.x, size.y, size.z);

    const cameraDistance = Math.max(maxDim, 1000) * 2.5;

    controls.target.copy(center);

    camera.position.set(
      center.x + cameraDistance * 0.7,
      center.y + cameraDistance * 0.7,
      center.z + cameraDistance * 0.7
    );

    camera.near = 0.01;
    camera.far = 1e7;
    camera.updateProjectionMatrix();

    controls.minDistance = 0.01;
    controls.maxDistance = cameraDistance * 2;

    controls.update();
  } else {
    controls.update();
  }
}

fileInput.addEventListener('change', (ev)=>{
  const f = ev.target.files[0];
  if (!f) return;
  const reader = new FileReader();

  reader.onload = (e) => {
    lastLoadedRows = parseCSV(e.target.result);
    if (lastLoadedRows.length === 0) { return; }

    let sumX = 0, sumY = 0, sumZ = 0;
    let validCount = 0;

    lastLoadedRows.forEach(r => {
        const x = parseFloat(r.X), y = parseFloat(r.Y), z = parseFloat(r.Z);
        if (!isNaN(x) && !isNaN(y) && !isNaN(z)) {
            sumX += x; sumY += y; sumZ += z;
            validCount++;
        }
    });

    if (validCount === 0) { return; }

    sceneCenterOffset.set(
        sumX / validCount,
        sumY / validCount,
        sumZ / validCount
    );

    controls.target.set(0,0,0);

    updateSceneFromData();
  };

  reader.readAsText(f);
});

function onCanvasClick(event) {
  const rect = renderer.domElement.getBoundingClientRect();
  mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
  mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

  raycaster.setFromCamera(mouse, camera);

  const intersects = raycaster.intersectObjects(rootGroup.children, true);
  const hit = intersects.find(h => h.object.geometry.type === 'SphereGeometry');

  if (hit) {
    const group = hit.object.parent;
    if (group && group.userData.displayData) {
      const data = group.userData.displayData;

      tooltip.innerHTML = `
        <strong>X (UTM):</strong> ${data.X}<br>
        <strong>Y (UTM):</strong> ${data.Y}<br>
        <strong>Z (m):</strong> ${data.Z}<br>
        <strong>Md:</strong> ${data.Md}<br>
        <strong>Strike:</strong> ${data.Strike}<br>
        <strong>Dip (CSV):</strong> ${data.Dip}<br>
        <strong>Rake:</strong> ${data.Rake}
      `;
      tooltip.style.display = 'block';
      tooltip.style.left = (event.clientX + 10) + 'px';
      tooltip.style.top = (event.clientY + 10) + 'px';
    }
  } else {
    tooltip.style.display = 'none';
  }
}

function onWindowResize(){
  const w = container.clientWidth, h = container.clientHeight;
  camera.aspect = w/h;
  camera.updateProjectionMatrix();
  renderer.setSize(w,h);
}

function animate() {
  requestAnimationFrame(animate);
  controls.update();
  renderer.render(scene, camera);
}
</script>
</body>
</html>
