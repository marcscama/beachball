<!doctype html>
<html lang="it">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Beachballs Viewer</title>
<style>
  html,body { height:100%; margin:0; background: linear-gradient(to bottom, #f6f6f6 0%, #d0d0d0 30%, #9a9a9a 75%, #6b6b6b 100%); font-family:system-ui,Segoe UI,Roboto,Arial; }
  #app { height:100vh; display:flex; flex-direction:column; }
  #topbar { padding:8px; background:#fff; box-shadow:0 1px 4px rgba(0,0,0,0.06); display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
  #canvaswrap { flex:1; position:relative; overflow:hidden; }
  canvas { display:block; width:100%; height:100%; }
  label { font-size:13px; }
  input[type="file"] { display:inline-block; }
  .controls { margin-left:auto; display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
  #tooltip {
    position: absolute;
    display: none;
    padding: 8px;
    background: rgba(0,0,0,0.75);
    color: white;
    border-radius: 4px;
    font-size: 12px;
    pointer-events: none;
    line-height: 1.4;
    z-index: 100;
  }
  #exportBtn {
    margin-left:10px;
    padding:4px 12px;
    cursor:pointer;
    background:#4CAF50;
    color:white;
    border:none;
    border-radius:4px;
    font-size:13px;
  }
  #exportBtn:hover { background:#45a049; }
  #exportBtn:disabled { background:#cccccc; cursor:not-allowed; }
</style>
<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@latest/build/three.module.js",
    "three/addons/": "https://cdn.jsdelivr.net/npm/three@latest/examples/jsm/"
  }
}
</script>
</head>
<body>
<div id="app">
  <div id="topbar">
    <label class="info">CSV header= (X,Y in UTM,Z in metri negativi,Md o Ml,Date,Time o Time,Strike,Dip,Rake - case sensitive):</label>
    <input id="file" type="file" accept=".csv" />
    <div class="controls">
      <label>Moltiplicatore Raggio (M³ × k):</label>
      <input id="radiusScale" type="range" min="0.1" max="3" step="0.05" value="1.5" />
      <span id="scaleVal">1.5</span>
      <label style="margin-left:10px;"><input id="showPlanes" type="checkbox" checked /> Piani di faglia</label>
      <button id="exportBtn">Esporta GLB</button>
    </div>
  </div>
  <div id="canvaswrap">
    <div id="tooltip"></div>
  </div>
</div>

<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
import { GLTFExporter } from 'three/addons/exporters/GLTFExporter.js';

const container = document.getElementById('canvaswrap');
const fileInput = document.getElementById('file');
const showPlanesCheckbox = document.getElementById('showPlanes');
const tooltip = document.getElementById('tooltip');
const radiusScaleInput = document.getElementById('radiusScale');
const scaleValSpan = document.getElementById('scaleVal');
const exportBtn = document.getElementById('exportBtn');

let scene, camera, renderer, controls;
let rootGroup;
let raycaster, mouse;
let axesGroup = null;
let directionalLight;
let lastLoadedRows = [];
let sceneCenterOffset = new THREE.Vector3(0, 0, 0);
let csvHasMd = false;
let csvHasMl = false;

const d2r = deg => deg * Math.PI / 180;

initScene();
animate();

function initScene(){
  scene = new THREE.Scene();
  scene.background = null;
  const w = container.clientWidth, h = container.clientHeight;
  camera = new THREE.PerspectiveCamera(45, w/h, 0.1, 1e7);
  camera.position.set(5000, 5000, 5000);
  renderer = new THREE.WebGLRenderer({ antialias: true, logarithmicDepthBuffer: false });
  renderer.sortObjects = false;
  renderer.setPixelRatio(window.devicePixelRatio);
  renderer.setSize(container.clientWidth, container.clientHeight);
  renderer.setClearColor(0x000000, 0);
  container.appendChild(renderer.domElement);
  controls = new OrbitControls(camera, renderer.domElement);
  controls.target.set(0,0,0);
  controls.minDistance = 0.1;
  controls.maxDistance = 10000;
  controls.zoomSpeed = 10.0;
  controls.enableDamping = true;
  controls.dampingFactor = 0.05;
  controls.mouseButtons.LEFT = THREE.MOUSE.ROTATE;
  controls.mouseButtons.MIDDLE = THREE.MOUSE.DOLLY;
  controls.mouseButtons.RIGHT = THREE.MOUSE.PAN;
  controls.update();
  directionalLight = new THREE.DirectionalLight(0xffffff, 2.55);
  scene.add(directionalLight);
  scene.add(new THREE.AmbientLight(0xffffff, 0.8));
  rootGroup = new THREE.Group();
  scene.add(rootGroup);
  raycaster = new THREE.Raycaster();
  mouse = new THREE.Vector2();
  renderer.domElement.addEventListener('click', onCanvasClick);
  controls.addEventListener('start', () => { tooltip.style.display = 'none'; });
  scaleValSpan.textContent = radiusScaleInput.value;
  radiusScaleInput.addEventListener('input', () => { scaleValSpan.textContent = radiusScaleInput.value; updateSceneFromData(); });
  showPlanesCheckbox.addEventListener('change', () => { updateSceneFromData(); });
  window.addEventListener('resize', onWindowResize);
}

function get_enu_vectors(strikeDeg, dipDeg, rakeDeg) {
  const strike_rad = d2r(strikeDeg);
  const dip_direction = d2r(strikeDeg - 90);
  const delta = d2r(dipDeg);
  const lambda = d2r(rakeDeg);
  const sin_strike = Math.sin(strike_rad);
  const cos_strike = Math.cos(strike_rad);
  const sin_dip_dir = Math.sin(dip_direction);
  const cos_dip_dir = Math.cos(dip_direction);
  const sin_delta = Math.sin(delta);
  const cos_delta = Math.cos(delta);
  const n_e = sin_delta * sin_dip_dir;
  const n_n = sin_delta * cos_dip_dir;
  const n_u = cos_delta;
  const t_e = sin_strike;
  const t_n = cos_strike;
  const t_u = 0.0;
  const cross_e = n_n * t_u - n_u * t_n;
  const cross_n = n_u * t_e - n_e * t_u;
  const cross_u = n_e * t_n - n_n * t_e;
  const cross_mag = Math.sqrt(cross_e*cross_e + cross_n*cross_n + cross_u*cross_u) || 1.0;
  const d_e = cross_e / cross_mag;
  const d_n = cross_n / cross_mag;
  const d_u = cross_u / cross_mag;
  const s_e = Math.cos(lambda) * t_e + Math.sin(lambda) * d_e;
  const s_n = Math.cos(lambda) * t_n + Math.sin(lambda) * d_n;
  const s_u = Math.cos(lambda) * t_u + Math.sin(lambda) * d_u;
  const n_enu = new THREE.Vector3(n_e, n_n, n_u).normalize();
  const s_enu = new THREE.Vector3(s_e, s_n, s_u).normalize();
  return { n_enu, s_enu };
}

function get_threejs_vectors(strike, dip, rake) {
  const { n_enu, s_enu } = get_enu_vectors(strike, dip, rake);
  const n_three = new THREE.Vector3(n_enu.x, n_enu.z, -n_enu.y).normalize();
  const s_three = new THREE.Vector3(s_enu.x, s_enu.z, -s_enu.y).normalize();
  return { n: n_three, s: s_three };
}

function buildMomentTensorFromSDR(strike, dip, rake) {
  const { n, s } = get_threejs_vectors(strike, dip, rake);
  return [
    s.x * n.x + n.x * s.x, s.x * n.y + n.x * s.y, s.x * n.z + n.x * s.z,
    s.y * n.x + n.y * s.x, s.y * n.y + n.y * s.y, s.y * n.z + n.y * s.z,
    s.z * n.x + n.z * s.x, s.z * n.y + n.z * s.y, s.z * n.z + n.z * s.z
  ];
}

function makeMomentBallMaterial(momentArray) {
  return new THREE.ShaderMaterial({
    uniforms: {
      lightDir: { value: new THREE.Vector3(1,2,3).normalize() },
      M: { value: momentArray.map(v=>v) },
      colorComp: { value: new THREE.Color(0xc00000) },
      colorDilat: { value: new THREE.Color(0xf0f0f0) }
    },
    vertexShader: `
      varying vec3 vWNormal;
      void main(){
        vWNormal = normalize((modelMatrix * vec4(normal, 0.0)).xyz);
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);
      }`,
    fragmentShader: `
      uniform vec3 lightDir;
      uniform float M[9];
      uniform vec3 colorComp;
      uniform vec3 colorDilat;
      varying vec3 vWNormal;
      vec3 Mmul_u(vec3 u) {
        return vec3(
          M[0]*u.x + M[1]*u.y + M[2]*u.z,
          M[3]*u.x + M[4]*u.y + M[5]*u.z,
          M[6]*u.x + M[7]*u.y + M[8]*u.z
        );
      }
      void main(){
        vec3 u = normalize(vWNormal);
        vec3 Mu = Mmul_u(u);
        float sigma = dot(u, Mu);
        float t = smoothstep(-0.0006, 0.0006, sigma);
        vec3 baseCol = mix(colorComp, colorDilat, t);
        float L = max(dot(u, normalize(lightDir)), 0.0);
        vec3 shaded = baseCol * (0.25 + 0.75 * L);
        gl_FragColor = vec4(shaded, 1.0);
      }`,
    side: THREE.DoubleSide,
    transparent: false
  });
}

function createEventMesh(relX, relY, relZ, origX, origY, origZ, Md, Ml, strike, dip, rake, options = {}) {
  const radiusMultiplier = options.radiusMultiplier ?? 1.5;
  const minRadius = 5.0;
  const magForRadius = Md !== null ? Md : (Ml !== null ? Ml : 1.0);
  const radius = Math.max(minRadius, (magForRadius ** 3) * radiusMultiplier);
  const { n: faultNormalYUp, s: slipVectorYUp } = get_threejs_vectors(strike, dip, rake);
  const M = buildMomentTensorFromSDR(strike, dip, rake);
  const mat = makeMomentBallMaterial(M);
  const geom = new THREE.SphereGeometry(radius, 128, 96);
  const sph = new THREE.Mesh(geom, mat);
  sph.castShadow = true; sph.receiveShadow = true;
  sph.renderOrder = 10;

  const group = new THREE.Group();
  group.add(sph);
  if (showPlanesCheckbox.checked) {
    const planeSize = radius * 6;
    const planeGeometry = new THREE.PlaneGeometry(planeSize, planeSize);
    const planeMaterial = new THREE.MeshBasicMaterial({ 
      color: 0xffea66, 
      opacity: 0.45,
      transparent: true,
      side: THREE.DoubleSide,
      depthWrite: false
    });
    const plane = new THREE.Mesh(planeGeometry, planeMaterial);
    plane.renderOrder = 1;
    const zAxisDefault = new THREE.Vector3(0, 0, 1);
    const rotationQuaternion = new THREE.Quaternion().setFromUnitVectors(zAxisDefault, faultNormalYUp);
    plane.quaternion.copy(rotationQuaternion);
    plane.position.copy(faultNormalYUp).multiplyScalar(0.001);
    group.add(plane);
  }
  const posx = relX;
  const posy = relZ;
  const posz = -relY;
  group.position.set(posx, posy, posz);
  group.userData = {
    displayData: {
      X: origX.toFixed(2),
      Y: origY.toFixed(2),
      Z: origZ.toFixed(2),
      Md: Md !== null ? Md.toFixed(2) : null,
      Ml: Ml !== null ? Ml.toFixed(2) : null,
      Strike: strike.toFixed(2),
      Dip: dip.toFixed(2),
      Rake: rake.toFixed(2)
    }
  };
  return group;
}

function parseCSV(text) {
  const lines = text.trim().split(/\r?\n/).map(l=>l.trim()).filter(l=>l.length>0);
  if (lines.length < 2) return [];
  const header = lines[0].split(',').map(s=>s.trim());
  csvHasMd = header.includes('Md');
  csvHasMl = header.includes('Ml');
  const rows = [];
  for (let i=1;i<lines.length;i++){
    const cols = lines[i].split(',').map(s=>s.trim());
    if (cols.length < header.length) { continue; }
    const obj = {};
    for (let j=0;j<header.length;j++){ obj[header[j]] = cols[j]; }
    rows.push(obj);
  }
  return rows;
}

function calculateOffset(rows) {
  let sumX = 0, sumY = 0, sumZ = 0;
  let validCount = 0;
  rows.forEach(r => {
    const x_val = r.X || r.Lon;
    const y_val = r.Y || r.Lat;
    const z_val = r.Z || r.sphere;
    const x = parseFloat(x_val), y = parseFloat(y_val), z = parseFloat(z_val);
    if (!isNaN(x) && !isNaN(y) && !isNaN(z)) { sumX += x; sumY += y; sumZ += z; validCount++; }
  });
  if (validCount > 0) sceneCenterOffset.set(sumX / validCount, sumY / validCount, sumZ / validCount); else sceneCenterOffset.set(0, 0, 0);
}

function disposeMaterial(m) { if (!m) return; if (Array.isArray(m)) m.forEach(x=>{ if (x.map) x.map.dispose(); x.dispose(); }); else { if (m.map) m.map.dispose(); m.dispose(); } }

function clearEvents() {
  while (rootGroup.children.length) {
    const c = rootGroup.children[0];
    c.traverse(o=>{ if (o.geometry) o.geometry.dispose(); if (o.material) disposeMaterial(o.material); });
    rootGroup.remove(c);
  }
  if (axesGroup) { axesGroup.traverse(o=>{ if (o.geometry) o.geometry.dispose(); if (o.material) disposeMaterial(o.material); }); scene.remove(axesGroup); axesGroup = null; }
}

function createTextSprite(text, color='#0000ff') {
  const canvas = document.createElement('canvas'); 
  const size = 256; 
  canvas.width = size; 
  canvas.height = size; 
  const ctx = canvas.getContext('2d'); 
  ctx.clearRect(0,0,size,size); 
  ctx.font = 'bold 32px Arial'; 
  ctx.textAlign = 'center'; 
  ctx.textBaseline = 'middle'; 
  ctx.fillStyle = color; 
  ctx.fillText(text, size/2, size/2); 
  const texture = new THREE.CanvasTexture(canvas); 
  texture.needsUpdate = true; 
  const mat = new THREE.SpriteMaterial({ map: texture });
  const sprite = new THREE.Sprite(mat); 
  sprite.scale.set(400, 100, 1); 
  sprite.renderOrder = -999;
  return sprite;
}

function drawAxes(center, size) {
  if (axesGroup) { axesGroup.traverse(o=>{ if (o.geometry) o.geometry.dispose(); if (o.material) disposeMaterial(o.material); }); scene.remove(axesGroup); axesGroup = null; }
  axesGroup = new THREE.Group();
  const axisLen = Math.max(size.x || 0, size.z || 0, 1000) * 2.0;
  const halfX = axisLen / 2;
  const worldY0 = 0 - sceneCenterOffset.z;
  const matX = new THREE.LineBasicMaterial({ color: 0xff0000 });
  const matZ = new THREE.LineBasicMaterial({ color: 0x00aa00 });
  const matY = new THREE.LineBasicMaterial({ color: 0x0000ff });
  const xGeo = new THREE.BufferGeometry().setFromPoints([ 
    new THREE.Vector3(center.x - halfX, worldY0, center.z), 
    new THREE.Vector3(center.x + halfX, worldY0, center.z) 
  ]);
  const xLine = new THREE.Line(xGeo, matX);
  xLine.renderOrder = -999;
  axesGroup.add(xLine);
  const labelXE = createTextSprite('X-E', '#ff0000');
  labelXE.position.set(center.x + halfX + 200, worldY0, center.z);
  axesGroup.add(labelXE);
  const labelXW = createTextSprite('X-W', '#ff0000');
  labelXW.position.set(center.x - halfX - 200, worldY0, center.z);
  axesGroup.add(labelXW);
  const zGeo = new THREE.BufferGeometry().setFromPoints([ 
    new THREE.Vector3(center.x, worldY0, center.z - halfX), 
    new THREE.Vector3(center.x, worldY0, center.z + halfX) 
  ]);
  const zLine = new THREE.Line(zGeo, matZ);
  zLine.renderOrder = -999;
  axesGroup.add(zLine);
  const labelN = createTextSprite('N-(Z=-Y)', '#00aa00');
  labelN.position.set(center.x, worldY0, center.z - halfX - 200);
  axesGroup.add(labelN);
  const labelS = createTextSprite('S-(Z=Y)', '#00aa00');
  labelS.position.set(center.x, worldY0, center.z + halfX + 200);
  axesGroup.add(labelS);
  const maxsphere = 5000;
  const yTop = worldY0;
  const yBottom = (-maxsphere) - sceneCenterOffset.z;
  const yGeo = new THREE.BufferGeometry().setFromPoints([ 
    new THREE.Vector3(center.x, yTop, center.z), 
    new THREE.Vector3(center.x, yBottom, center.z) 
  ]);
  const yLine = new THREE.Line(yGeo, matY);
  yLine.renderOrder = -999;
  axesGroup.add(yLine);
  const labelZPlus = createTextSprite('Z+(Y=Z)', '#0000ff');
  labelZPlus.position.set(center.x + 300, yTop + 100, center.z);
  axesGroup.add(labelZPlus);
  const labelZMinus = createTextSprite('Z-(Y=-Z)', '#0000ff');
  labelZMinus.position.set(center.x + 300, yBottom - 100, center.z);
  axesGroup.add(labelZMinus);
  const tickStep = 500;
  const tickLen = Math.max(axisLen * 0.01, 10);
  for (let d = 0; d >= -maxsphere; d -= tickStep) {
    const yWorld = d - sceneCenterOffset.z;
    const tGeo = new THREE.BufferGeometry().setFromPoints([ 
      new THREE.Vector3(center.x - tickLen*0.5, yWorld, center.z), 
      new THREE.Vector3(center.x + tickLen*0.5, yWorld, center.z) 
    ]);
    const tLine = new THREE.Line(tGeo, matY);
    tLine.renderOrder = -999;
    axesGroup.add(tLine);
    const labelText = String(d);
    const sprite = createTextSprite(labelText, '#0000ff');
    sprite.position.set(center.x + tickLen + 100, yWorld, center.z);
    axesGroup.add(sprite);
  }
  scene.add(axesGroup);
}

function parseToDate(str) {
  if (!str) return null;
  str = String(str).trim();
  const dm = str.match(/^(\d{1,2})\/(\d{1,2})\/(\d{2,4})(?:[ T](.*))?$/);
  if (dm) {
    const day = Number(dm[1]);
    const month = Number(dm[2]);
    let year = Number(dm[3]);
    const timePart = dm[4] || '00:00:00';
    if (year < 100) year += 2000;
    const t = (timePart.split('.'))[0];
    const iso = `${year.toString().padStart(4,'0')}-${String(month).padStart(2,'0')}-${String(day).padStart(2,'0')}T${t}`;
    const d = new Date(iso);
    if (!isNaN(d)) return d;
  }
  let s = str.replace(' ', 'T');
  s = s.replace(/(\.\d{3})\d+/, '$1');
  let d = new Date(s);
  if (!isNaN(d)) return d;
  d = new Date(str);
  if (!isNaN(d)) return d;
  return null;
}

function formatDateToDDMMYYYY_HHMMSS(d) {
  if (!d) return '';
  const pad = n => String(n).padStart(2,'0');
  const day = pad(d.getUTCDate());
  const month = pad(d.getUTCMonth()+1);
  const year = d.getUTCFullYear();
  const hours = pad(d.getUTCHours());
  const mins = pad(d.getUTCMinutes());
  const secs = pad(d.getUTCSeconds());
  return `${day}/${month}/${year} ${hours}:${mins}:${secs}`;
}

function updateSceneFromData() {
  if (lastLoadedRows.length === 0) return;
  clearEvents();
  const currentRadiusMultiplier = parseFloat(radiusScaleInput.value);
  const bbox = new THREE.Box3();
  lastLoadedRows.forEach(r=>{
    const x = parseFloat(r.X), y = parseFloat(r.Y), z = parseFloat(r.Z);
    const Md_val = csvHasMd ? parseFloat(r.Md) : null;
    const Ml_val = csvHasMl ? parseFloat(r.Ml) : null;
    let Md = !isNaN(Md_val) ? Md_val : null;
    let Ml = !isNaN(Ml_val) ? Ml_val : null;
    if (Md === null && Ml === null) {
      const mag = parseFloat(r.Mag);
      if (!isNaN(mag)) Ml = mag;
    }
    const strike = parseFloat(r.Strike) || 0;
    const dip = parseFloat(r.Dip) || 90;
    const rake = parseFloat(r.Rake) || 0;
    if (isNaN(x)||isNaN(y)||isNaN(z)) return;
    const relX = x - sceneCenterOffset.x;
    const relY = y - sceneCenterOffset.y;
    const relZ = z - sceneCenterOffset.z;
    const meshGroup = createEventMesh(relX, relY, relZ, x, y, z, Md, Ml, strike, dip, rake, { radiusMultiplier: currentRadiusMultiplier });
    let dtString = null;
    if (r.Date && r.Time) dtString = `${r.Date} ${r.Time}`;
    else if (r.Time) dtString = r.Time;
    else if (r.Date) dtString = r.Date;
    else if (r.Timestamp) dtString = r.Timestamp;
    const parsed = parseToDate(dtString);
    const formattedTime = parsed ? formatDateToDDMMYYYY_HHMMSS(parsed) : (dtString || '');
    if (!meshGroup.userData) meshGroup.userData = {};
    if (!meshGroup.userData.displayData) meshGroup.userData.displayData = {};
    meshGroup.userData.displayData.Time = formattedTime;
    rootGroup.add(meshGroup);
    bbox.expandByPoint(meshGroup.position);
  });
  if (rootGroup.children.length > 0) {
    const center = new THREE.Vector3();
    bbox.getCenter(center);
    const size = new THREE.Vector3();
    bbox.getSize(size);
    const maxDim = Math.max(size.x, size.y, size.z);
    const cameraDistance = Math.max(maxDim, 1000) * 2.5;
    controls.target.copy(center);
    camera.position.set(center.x + cameraDistance * 0.7, center.y + cameraDistance * 0.7, center.z + cameraDistance * 0.7);
    camera.near = 0.1;
    camera.far = 1e7;
    camera.updateProjectionMatrix();
    controls.minDistance = 0.1;
    controls.maxDistance = cameraDistance * 2;
    controls.update();
    drawAxes(center, size);
  } else { controls.update(); }
}

fileInput.addEventListener('change', (ev)=>{
  const f = ev.target.files[0];
  if (!f) return;
  const reader = new FileReader();
  reader.onload = (e) => {
    lastLoadedRows = parseCSV(e.target.result);
    if (lastLoadedRows.length === 0) { alert("Nessun dato valido trovato nel CSV."); return; }
    calculateOffset(lastLoadedRows);
    controls.target.set(0,0,0);
    updateSceneFromData();
  };
  reader.readAsText(f);
});

function onCanvasClick(event) {
  const rect = renderer.domElement.getBoundingClientRect();
  mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
  mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
  raycaster.setFromCamera(mouse, camera);
  const intersects = raycaster.intersectObjects(rootGroup.children, true);
  const hit = intersects.find(h => h.object.geometry && h.object.geometry.type === 'SphereGeometry');
  if (hit) {
    const group = hit.object.parent;
    if (group && group.userData.displayData) {
      const data = group.userData.displayData;
      let tooltipHTML = `<strong>X/UTM:</strong> ${data.X}<br><strong>Y/UTM:</strong> ${data.Y}<br><strong>Z/Depth:</strong> ${data.Z}<br>`;
      if (data.Md !== null && data.Ml !== null) {
        tooltipHTML += `<strong>Md:</strong> ${data.Md}<br><strong>Ml:</strong> ${data.Ml}<br>`;
      } else if (data.Md !== null) {
        tooltipHTML += `<strong>Md:</strong> ${data.Md}<br>`;
      } else if (data.Ml !== null) {
        tooltipHTML += `<strong>Ml:</strong> ${data.Ml}<br>`;
      }
      tooltipHTML += `<strong>Strike:</strong> ${data.Strike}°<br><strong>Dip:</strong> ${data.Dip}°<br><strong>Rake:</strong> ${data.Rake}°<br>`;
      if (data.Time) tooltipHTML += `<strong>Time:</strong> ${data.Time}<br>`;
      tooltip.innerHTML = tooltipHTML;
      tooltip.style.display = 'block';
      tooltip.style.left = (event.clientX + 10) + 'px';
      tooltip.style.top = (event.clientY + 10) + 'px';
    }
  } else { tooltip.style.display = 'none'; }
}

function onWindowResize(){ const w = container.clientWidth, h = container.clientHeight; camera.aspect = w/h; camera.updateProjectionMatrix(); renderer.setSize(w,h); }

function animate() { 
  requestAnimationFrame(animate); 
  controls.update(); 
  const lightDirection = new THREE.Vector3();
  camera.getWorldDirection(lightDirection);
  lightDirection.multiplyScalar(-1);
  directionalLight.position.copy(camera.position).add(lightDirection.multiplyScalar(100));
  rootGroup.children.forEach(child => {
    child.traverse(obj => {
      if (obj.material && obj.material.uniforms && obj.material.uniforms.lightDir) {
        const dir = new THREE.Vector3();
        camera.getWorldDirection(dir);
        dir.multiplyScalar(-1);
        obj.material.uniforms.lightDir.value.copy(dir.normalize());
      }
    });
  });
  renderer.render(scene, camera); 
}

// ========== FUNZIONI DI ESPORTAZIONE GLB ==========

function bakeShaderColorsToGeometry(mesh) {
  const geometry = mesh.geometry;
  const material = mesh.material;
  
  if (!material.uniforms || !material.uniforms.M) {
    return geometry;
  }
  
  const bakedGeometry = geometry.clone();
  const positions = bakedGeometry.attributes.position;
  const normals = bakedGeometry.attributes.normal;
  const vertexCount = positions.count;
  const colors = new Float32Array(vertexCount * 3);
  
  const M = material.uniforms.M.value;
  const lightDir = material.uniforms.lightDir.value.clone().normalize();
  const colorComp = material.uniforms.colorComp.value;
  const colorDilat = material.uniforms.colorDilat.value;
  
  // Usa la matrice world del mesh per il bake corretto
  const normalMatrix = new THREE.Matrix3().getNormalMatrix(mesh.matrixWorld);
  
  for (let i = 0; i < vertexCount; i++) {
    const nx = normals.getX(i);
    const ny = normals.getY(i);
    const nz = normals.getZ(i);
    
    // Trasforma la normale nello spazio world
    const worldNormal = new THREE.Vector3(nx, ny, nz);
    worldNormal.applyMatrix3(normalMatrix).normalize();
    
    // Calcola M·u
    const Mu_x = M[0] * worldNormal.x + M[1] * worldNormal.y + M[2] * worldNormal.z;
    const Mu_y = M[3] * worldNormal.x + M[4] * worldNormal.y + M[5] * worldNormal.z;
    const Mu_z = M[6] * worldNormal.x + M[7] * worldNormal.y + M[8] * worldNormal.z;
    
    // Calcola sigma = u·M·u
    const sigma = worldNormal.x * Mu_x + worldNormal.y * Mu_y + worldNormal.z * Mu_z;
    
    // Smoothstep con soglia ridotta per colori più distinti
    const smoothstep = (edge0, edge1, x) => {
      const t = Math.max(0, Math.min(1, (x - edge0) / (edge1 - edge0)));
      return t * t * (3 - 2 * t);
    };
    const t = smoothstep(-0.00035, 0.00035, sigma);
    
    // Interpola tra colore compressione e dilatazione
    const baseColor = new THREE.Color().lerpColors(colorComp, colorDilat, t);
    
    // Applica illuminazione leggermente potenziata per export
    const L = Math.max(0, worldNormal.dot(lightDir));
    const shadedColor = baseColor.clone().multiplyScalar(0.3 + 0.7 * L);
    
    colors[i * 3 + 0] = shadedColor.r;
    colors[i * 3 + 1] = shadedColor.g;
    colors[i * 3 + 2] = shadedColor.b;
  }
  
  bakedGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
  
  return bakedGeometry;
}

function prepareSceneForExport() {
  const exportGroup = new THREE.Group();
  
  rootGroup.children.forEach(eventGroup => {
    const clonedGroup = new THREE.Group();
    
    // Copia le trasformazioni world direttamente
    clonedGroup.position.copy(eventGroup.position);
    clonedGroup.rotation.copy(eventGroup.rotation);
    clonedGroup.scale.copy(eventGroup.scale);
    clonedGroup.updateMatrix();
    
    eventGroup.children.forEach(child => {
      if (child.geometry && child.geometry.type === 'SphereGeometry') {
        // Bake il shader sui colori
        const bakedGeometry = bakeShaderColorsToGeometry(child);
        
        // Material standard per export
        const standardMaterial = new THREE.MeshStandardMaterial({
          vertexColors: true,
          roughness: 0.4,
          metalness: 0.0,
          side: THREE.DoubleSide
        });
        
        const bakedMesh = new THREE.Mesh(bakedGeometry, standardMaterial);
        
        // Preserva le trasformazioni locali
        bakedMesh.position.copy(child.position);
        bakedMesh.rotation.copy(child.rotation);
        bakedMesh.scale.copy(child.scale);
        bakedMesh.updateMatrix();
        
        clonedGroup.add(bakedMesh);
      } else if (child.geometry && child.geometry.type === 'PlaneGeometry') {
        const planeGeometry = child.geometry.clone();
        const planeMaterial = new THREE.MeshStandardMaterial({
          color: 0xffea66,
          opacity: 0.45,
          transparent: true,
          side: THREE.DoubleSide,
          roughness: 0.5,
          metalness: 0.0
        });
        
        const planeMesh = new THREE.Mesh(planeGeometry, planeMaterial);
        
        // Preserva le trasformazioni locali
        planeMesh.position.copy(child.position);
        planeMesh.rotation.copy(child.rotation);
        planeMesh.scale.copy(child.scale);
        planeMesh.updateMatrix();
        
        clonedGroup.add(planeMesh);
      }
    });
    
    exportGroup.add(clonedGroup);
  });
  
  // Aggiungi assi se presenti
  if (axesGroup) {
    const clonedAxes = axesGroup.clone();
    exportGroup.add(clonedAxes);
  }
  
  return exportGroup;
}

function exportSceneGLB() {
  if (rootGroup.children.length === 0) {
    alert('Nessun dato da esportare. Carica prima un file CSV.');
    return;
  }
  
  const exportGroup = prepareSceneForExport();
  const exporter = new GLTFExporter();
  
  const options = {
    binary: true,
    trs: true,
    onlyVisible: true,
    truncateDrawRange: true,
    embedImages: true,
    maxTextureSize: 4096
  };
  
  exportBtn.textContent = 'Esportazione...';
  exportBtn.disabled = true;
  
  exporter.parse(
    exportGroup,
    (result) => {
      saveArrayBuffer(result, 'beachballs_export.glb');
      
      exportBtn.textContent = 'Esporta GLB';
      exportBtn.disabled = false;
      
      // Cleanup
      exportGroup.traverse(obj => {
        if (obj.geometry) obj.geometry.dispose();
        if (obj.material) {
          if (Array.isArray(obj.material)) {
            obj.material.forEach(m => {
              if (m.map) m.map.dispose();
              m.dispose();
            });
          } else {
            if (obj.material.map) obj.material.map.dispose();
            obj.material.dispose();
          }
        }
      });
    },
    (error) => {
      console.error('Errore durante l\'esportazione:', error);
      alert('Errore durante l\'esportazione. Controlla la console.');
      exportBtn.textContent = 'Esporta GLB';
      exportBtn.disabled = false;
    },
    options
  );
}

function saveArrayBuffer(buffer, filename) {
  const blob = new Blob([buffer], { type: 'application/octet-stream' });
  const link = document.createElement('a');
  link.href = URL.createObjectURL(blob);
  link.download = filename;
  link.click();
  setTimeout(() => URL.revokeObjectURL(link.href), 1000);
}

exportBtn.addEventListener('click', exportSceneGLB);

</script>
</body>
</html>
